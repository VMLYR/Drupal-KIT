/**
* DO NOT EDIT THIS FILE.
*
**/
const merge = require('deepmerge');
// const { type } = require("ramda");

window.sectionVariants = {

  /**
   * Creates section variants per block variant that is passed via 'blockData'
   *
   * @param {*} blockData: either a single block's data (must include a label) OR an Object with block variants (must have 'variants' as first key)
   * @param {*} blockType: chosen machine name you use to identify the block type when used in Twig. eg. 'cb_text' is for the Text component
   * @param {*} sectionData: (optional) data of the layout section.
   * @param {*} sectionVariantsData: Object containing the section variants extra data (basically the options such as bg color that apply). Each variant is merged with sectionData in order to have complete data objects.
   */
  get: function(blockData, blockType, sectionData, sectionVariantsData) {

    var variants = false;
    var errorMsg = '';

    if (typeof blockData.variants !== 'undefined' && blockData.variants !== null && Object.keys(blockData.variants).length) {
      variants = true;
    } else {
      errorMsg = 'no variants data available';
      variants = false;
    }

    var sectionIndex = 0;
    var sectionVariantsComponentObject = {variants: {}};

    if (variants) {

      // loop the blockData variants
      for (var key in blockData.variants) {
        if (typeof blockData.variants[key] !== 'undefined') {

          // -- we also want each block variant, to be added to each section variant

          // loop the section data, for backgrounds
          for (var key2 in sectionVariantsData.variants) {
            if (typeof sectionVariantsData.variants[key2] !== 'undefined') {

              // merge the default section data with the variant
              var sectionVariant = merge(sectionData, sectionVariantsData.variants[key2]);

              // add the block data to it
              if (typeof sectionVariant.blocks === 'undefined') {
                sectionVariant.blocks = {};
              }
              sectionVariant.blocks[blockType] = blockData.variants[key];

              // add our section data to a new object to keep the old ones clean
              sectionVariantsComponentObject.variants[sectionIndex] = sectionVariant;
              ++sectionIndex;
            }
          }
        }

      }

    } else if (typeof blockData.label !== 'undefined') {

      // -- we also want each block variant, to be added to each section variant

      // loop the section data, for variant
      for (var key2 in sectionVariantsData.variants) {
        if (typeof sectionVariantsData.variants[key2] !== 'undefined') {

          // merge the default section data with the variant
          var sectionVariant = merge(sectionData, sectionVariantsData.variants[key2]);
          // add the block data to it
          if (typeof sectionVariant.blocks === 'undefined') {
            sectionVariant.blocks = {};
          }
          sectionVariant.blocks[blockType] = blockData;

          // add our section data to a new object to keep the old ones clean
          sectionVariantsComponentObject.variants[sectionIndex] = sectionVariant;
          ++sectionIndex;
        }
      }

    } else {
      console.error('Component data passed to sectionVariants get() function is empty or different structure than was expected.');
    }

    return sectionVariantsComponentObject;

  },

  /**
   * Returns all section variants with a key 'blocks' that contains all blocks passed via 'blockData'
   * @param {*} blockData
   * @param {*} sectionData
   * @param {*} sectionVariantsData
   */
  getGroup: function(blockData, sectionData, sectionVariantsData) {

    var variants = false;
    var errorMsg = '';

    if (typeof blockData.variants !== 'undefined' && blockData.variants !== null && Object.keys(blockData.variants).length) {
      variants = true;
    } else {
      errorMsg = 'no variants data available';
      variants = false;
    }

    var sectionIndex = 0;
    var sectionVariantsComponentObject = {variants: {}};

    if (variants) {

      // -- we want all the block variants to be added to each existing section variant

      // loop the section data, for variants
      for (var key2 in sectionVariantsData.variants) {
        if (typeof sectionVariantsData.variants[key2] !== 'undefined') {

          // merge the default section data with the variant data
          var sectionVariant = merge(sectionData, sectionVariantsData.variants[key2]);

          // add the blocks data to it
          if (typeof sectionVariant.blocks === 'undefined') {
            sectionVariant.blocks = {};
          }
          sectionVariant.blocks = blockData.variants;

          // add our section data to a new object to keep the old ones clean
          sectionVariantsComponentObject.variants[sectionIndex] = sectionVariant;
          ++sectionIndex;
        }
      }

    // if only 1 block
    } else if (typeof blockData.label !== 'undefined') {

      // -- we also want the single block, to be added to each section variant

      // loop the section data, for backgrounds
      for (var key2 in sectionVariantsData.variants) {
        if (typeof sectionVariantsData.variants[key2] !== 'undefined') {

          // merge the default section data with the variant
          var sectionVariant = merge(sectionData, sectionVariantsData.variants[key2]);
          // add the block data to it
          if (typeof sectionVariant.blocks === 'undefined') {
            sectionVariant.blocks = {};
          }
          sectionVariant.blocks = { 0: blockData };

          // add our section data to a new object to keep the old ones clean
          sectionVariantsComponentObject.variants[sectionIndex] = sectionVariant;
          ++sectionIndex;
        }
      }

    } else {
      console.error('Component data passed to sectionVariants get() function is empty or different structure than was expected.');
    }

    return sectionVariantsComponentObject;

  }
};
